---
title: "Assignment 2"
---
General considerations website layout:  
Data about the bribe; time, place, amount, category, etc. is available from the main search page.  
The full text describing the event is only available from the link itself. 
Can get most of the data from the main "search", without having to go through every link that has been pulled  


Let's generate and scrape the links of the reports first
```{r}
# load the required packages for the report and set options
require("rvest")
require("dplyr")
require("xml2")
require("readr")
require("stringr")
require("ggplot2")
require("raster")
require("sp")
require("splitstackshape")
options(scipen=999)
```

```{r}
# Create Dataset
## Initialize dataframe with the desired data columns
df <- data_frame(title = character(), 
                 amount = character(), 
                 dep = character(), 
                 trans = character(), 
                 views = character(),
                 city = character(),
                 date = character(), 
                 time = character())

## initialize empty dataframe for 
dftemp <- data_frame()

## Scrape data from "I paid a bribe" website

for (i in 0:99) { #loop through first 100 pages, 10 results per page = 1000 
  link <- paste("http://www.ipaidabribe.com/reports/paid?page=",i*10, sep = "") #Create hyperlink based on loop function
  print(paste("processing", i, sep = " ")) #progress report
  main <- read_html(link, encoding = "UTF-8") #define the static part of link references
  
  title <- main %>% 
    html_nodes(".heading-3 a") %>% 
    html_text() 
  
  amount <- main %>% # feed `main.page` to the next step
    html_nodes(".paid-amount span") %>% # get the CSS nodes
    html_text() # extract the link text
  
  dep <- main %>% # feed `main.page` to the next step
    html_nodes(".name a") %>% # get the CSS nodes
    html_text() # extract the link text
  
  trans <- main %>% # feed `main.page` to the next step
    html_nodes(".transaction a") %>% # get the CSS nodes
    html_text() # extract the link text
  
  views <- main %>% # feed `main.page` to the next step
    html_nodes(".overview .views") %>% # get the CSS nodes
    html_text() # extract the link text
  
  city <- main %>% # feed `main.page` to the next step
    html_nodes(".location") %>% # get the CSS nodes
    html_text() # extract the link text
  
  date <- main %>% # feed `main.page` to the next step
    html_nodes(".date") %>% # get the CSS nodes
    html_text() # extract the link text
  
  time <- main %>% # feed `main.page` to the next step
    html_nodes(".time-span") %>% # get the CSS nodes
    html_text() # extract the link text
  
  dftemp <- cbind(title, amount, dep, trans, views, city, date, time) #bind the variables together into a 10 by n dataframe
  df <- rbind(df,dftemp) #rbind the temp dataframe for this page to the main dataframe
  
  Sys.sleep(1) #timer, wait 1 second
  cat(" done!\n") #progress report
}

#clean unused variables from workspace
rm("title", "amount", "dep", "trans", "views", "city", "date", "time", "dftemp", "i")

## Split the city column into a city and state column

df$states <- lapply(strsplit(as.character(df$city), "\\,"), "[", 2)
df$city <- lapply(strsplit(as.character(df$city), "\\,"), "[", 1)

```

```{r}
## Clean and order dataset, force correct data types, factors for faceting and checking number of levels
clean <- function(df) {
df$title <- df$title %>% #clean text
  str_replace_all(pattern = "\\n" , replacement = " ") %>%
  str_trim()

df$dep <- df$dep %>% 
  as.factor() #convert to factor 

df$trans <- df$trans %>% 
  as.factor() #convert to factor 

df$amount <- df$amount %>% #clean text from amount and convert to numeric
  str_replace_all(pattern = "Paid INR" , replacement = " ") %>% 
  str_replace_all(pattern = "," , replacement = "") %>% 
  str_trim() %>% 
  as.numeric() 

df$views <- df$views %>% #clean text from views and convert to numeric
  str_replace_all(pattern = "views" , replacement = " ") %>%
  str_trim() %>% 
  as.numeric()

df$city <- df$city %>% #clean text from city
  as.character() %>%
  str_trim() %>%
  as.factor() # conver tot factor

df$states <- df$states %>% #clean text from states
  as.character(df$states) %>%
  str_trim() %>% 
  as.factor() #convert to factor

df$time <- as.numeric(str_extract(df$time,"[0-9]*"))*!grepl("minutes|hours",df$time) #clean hours and minutes out of time stamp and change to whole number of days

df$date <- as.Date(df$date, format("%B %d, %Y")) #convert the date column to date format

df <- df[, c(1,2,3,4,5,6,9,7,8)] #rearrange columns

return (df)

}

df <- clean(df)

## Suggestion: Analysis of Variance between transaction and amount per province or city

# Alternative to start of : 
# Arbirtrary list of variables and header locations in link, variable observations per pages
# 
# headers <- c("title", "amount", "dep", "trans", "views", "city", "date", "time", "link") #list of column names
# nodes <- c(".heading-3 a",".paid-amount span", ".name a", ".transaction a", ".overview .views", ".location", ".date", #".time-span", ".heading-3 a") #corresponding css nodes
# obsnr <- 10 #number of observations per page
# pgnr <- 99 #number of pages to loop through +1 (starts at 0)
# df <- data_frame() #initialize df as data frame
# dftemps <- data_frame() #initialize dftemps as dataframe
# 
# for (i in 0:pgnr) { #loop through first 100 pages, 10 results per page = 1000 
#   link <- paste("http://www.ipaidabribe.com/reports/paid?page=",i*obsnr, sep = "") #Create hyperlink based on loop function
#   print(paste("processing", i, sep = " ")) #progress report outer loop
#   main <- read_html(link, encoding = "UTF-8") #define the static part of link references
#       #begin inner loop, defining the dftemps results based on the header and node vectors
#       for (k in 1:length(headers)) { #dynamic length based on the number of headers
#       print(paste("processing", headers[[k]], sep = " ")) #progress report inner loop
#       dftemps[1:obsnr, headers[[k]]] <- #define the column name by the headers vector
#       if(headers[[k]] != "link") #test if the data is the link data, if it's not, standard html_text, if it is, html_attr()
#         main %>% #create column based on header name, fill with node data
#         html_nodes(nodes[[k]]) %>% 
#         html_text()
#       else #this is if it is the link data
#         main %>% 
#         html_nodes(nodes[[k]]) %>% 
#         html_attr(name = 'href')
#       }
#   
#   df <- rbind(df,dftemps) #bind dftemps to df, and iterate to next link.
#   Sys.sleep(1) #timer, wait 1 second
#   cat(" done!\n") #progress report
#   
#   }  
 
```

```{r}
#Import the common csv file from github to work on, at end of project remove this reference, lines to be removed marked with [X]

df_raw <- read_csv("https://raw.githubusercontent.com/TorJensen/Assignment-2/master/df.csv") #read csv file from github [X]
df_raw <- df_raw[,2:10] #remove the rownames column - [X]

df <- df_raw

df <- clean(df)
```

```{r}
# futher Data cleaning

## look at headers and footers for obvious outliers in bribe size

### sorted in descending value 
df %>% 
  arrange(desc(amount)) %>% 
  head(5) 
#one single value that is incredibly high, equivalent to 113 million euros for a birth certificate, this could be removed as an unlikely entry

### sorted in ascending order
df %>% 
  arrange(desc(desc(amount))) %>% 
  head(5)
#quite a few instances of Rs 1, not necessarily wrong, 1 Rs is 1.4 eurocent, very small bribe, but given relative poverty, could be reasonable? can't really argue for setting a minimum threshold for bribes. 

## look for missing values in the character variables (title, dep, trans, city, state)
dfmissing <- df %>% filter(title == "" | dep == "" | trans == "" | city == "" | states == "") %>% head(5)
dfmissing
#only a single entry with no data

## count number of rows with NA values
narows <- nrow(df[!complete.cases(df),])
narows
#total number is 0, no need to filter out NA values

## test for misassigned values in either 
duplicate <- match(df$city,df$states)
duplicate2 <- match(df$states,df$city)
dupcheck <- df[!is.na(duplicate),]
dupcheck2 <- df[!is.na(duplicate2),]
#3 values come up, city name is capital name, chandigarh is a state and an area so no problem

## filter based on the above criteria
df <- df %>% 
  filter(dep != "", amount < max(amount))  #Remove entry with missing data and remove the

## remove unwanted variables again used
rm("dfmissing", "narows", "duplicate", "duplicate2", "dupcheck", "dupcheck2")

```

```{r}
#exploratory data analysis 

summary(df)

#Basic summary shows birth large difference in mean and median amounts, third quartie and mean difference indicates large relatively small amount of large bribes pulling up the mean, while the vast majority of bribes reported are relatively small. Almost half of the bribes are reported from Bangalore, and about 2/3rds of the bribes are recorded within the top 5 departments.  The reporting period ends at 12th of october, so we only have 1 month worth of data, which limits the time/weekeday/seasonality analsysis options available. 

#plot showing amount of records per day
p <- ggplot(df %>% group_by(date) %>% summarise(count = n()),aes(date, count))
p + geom_bar(stat = "identity")

#Looking closer at the distribution of bribes submitted per day, we can see that the majority of our dataset was submitted on a single day last month. This is definitely an outlier compared to the other days that average about 10-30 reports per day. Having a look at the data for that specific day, it seems to be reasonably well-distributed across states and departments, so it can probably rules out that the reason is a barrage of spam / incorrect reports. 

#narrow down the the dataset to entries made on october 12rd
df_lump <- df %>% 
  filter(date == min(date)) #filter the data based on the earliest day in the dataset

summary(df_lump) # show summary data

# a quick google news search for october reveals that an article was posted in Times of India on the 11th of October, which could be a possible explanation for the sudden spike link: https://www.google.dk/search?q=ipaidabribe&num=100&espv=2&biw=1920&bih=1067&source=lnt&tbs=cdr%3A1%2Ccd_min%3A10%2F1%2F2015%2Ccd_max%3A10%2F31%2F2015&tbm=nws

# looking into relation between views and amount of data - do higher value bribe reports attract more attention 
p <- ggplot(df,aes(views, log(amount)))
p + geom_point(alpha = 0.4) #lower alpha (transparency) to be able to identify clusters of data
#doesn't seem to be any real relation, few outliers are for medium-sized amounts, but outlier status seems to be driven by other things than size in general
#a possibiliy could be a relation between the amount of text in each post - with a more descriptive "story" of the bribe than the standard, more views would be attracted, but this would require a further individual scrape of each posts' link to get the full comment text. 

## get an idea of the sizes of the factors in our dataset: 

levelcount <- lapply(df,levels) %>% summary
levelcount

#There are 27 states and 17 departments (with 40 transaction types) just in the 1000 records we have mined, so an analysis looking at transaction type level by state, for example, would need more than 1000 data points to be able to get a reasonable analysis (assuming some degree of normality.) Instead focus on higher level summaries, specific departments or specific states with a particular  


# Number of bribes and their sizes, by variables in various combinations:

### below are some tables looking at the 

#department
df_dep <- df %>% 
  group_by(dep) %>% 
  summarise(count = n(), amount = sum(amount))%>% 
  mutate(avgamount = round(amount/count)) %>% 
  arrange(desc(avgamount))
df_dep

#state
df_state <- df %>% 
  group_by(states) %>% 
  summarise(count = n(), amount = sum(amount))%>% 
  mutate(avgamount = round(amount/count)) %>% 
  arrange(desc(count))
df_state

#department and transaction type
df_deptrans <- df %>% 
  group_by(dep,trans) %>% 
  summarise(count = n(), sum = sum(amount))%>% 
  mutate(avgamount = round(sum/count))

#state and city
df_statecity <- df %>% 
  group_by(states, city) %>% 
  summarise(count = n(), sum = sum(amount)) %>% 
  mutate(avgamount = round(sum/count))

#state and department, the thougth was that some departments could be more corrupt in some areas compared to others, hard to tell with so few data for so many sates. 
df_statedep <- df %>% 
  group_by(states, dep) %>% 
  summarise(count = n(), sum = sum(amount)) %>% 
  mutate(avgamount = round(sum/count)) %>% 
  arrange(desc(count))

#number of views by state, are some states viewed more frequently, do states with lots of reports have more views, do states with a higher value of bribes have more views
df_stateviews <- df %>% 
  group_by(states) %>% 
  summarise(count = n(), views = sum(views), amount = sum(amount)) %>% 
  mutate(avgviews = round(views/count), avgamount = round(amount/count))

#number of views by department, are some departments viewed more frequently, do departments with lots of reports have more views, do departments with higher bribe value have more views.  
df_depviews <- df %>% 
  group_by(dep) %>% 
  summarise(count = n(), views = sum(views), amount = sum(amount)) %>% 
  mutate(avgviews = round(views/count), avgamount = round(amount/count))

#does number of views level out with time? 
df_viewsdate <- df %>% 
  group_by(date) %>% 
  summarise(count = n(), views = sum(views)) %>% 
  mutate(avgviews = round(views/count))
# commented this out while playing with dplyr
# bribe_sta <- aggregate(amount ~ states, df, sum)
# bribe_sta <- bribe_sta[-c(1),]
# bribe_sta <- bribe_sta %>% arrange(desc(amount))
```



#part janette
```{r}

#Bribe amounts
bribe_sta <- aggregate(amount ~ states, df, sum)
bribe_sta <- bribe_sta[-c(1),]
bribe_sta <- bribe_sta %>% arrange(desc(amount))


# pulling the GDP and population data of different states

#Distribution of GDP within the different states of India in 2013/14

#First we scrape the data from the web. 

GDPindia = read_html("https://en.wikipedia.org/wiki/List_of_Indian_states_by_GDP") %>%
  html_nodes(xpath = '//*[@id="mw-content-text"]/table[2]') %>% 
  html_table() %>% data.frame # then convert the HTML table into a data frame

GDPindia$GDP.in.2013.14..in.crore.rupees. = as.numeric(gsub("," , "" , GDPindia$GDP.in.2013.14..in.crore.rupees.)) #remove commas from indian number notation

GDPindia1 = mutate(GDPindia, GDP = GDP.in.2013.14..in.crore.rupees.*10000000) %>% as.data.frame() #1 crore is 10 million, convert to unit measure and stick it in a new dataframe

population = read_html("https://en.wikipedia.org/wiki/List_of_states_and_union_territories_of_India_by_population") %>%
  html_nodes(xpath = '//*[@id="mw-content-text"]/table[2]') %>% 
  html_table() %>% data.frame %>% select(State.or.union.territory, Population..2011.Census..12.....of.Population.of.India..13.)

population$one <- lapply(strsplit(as.character(population$Population..2011.Census..12.....of.Population.of.India..13.), "\\â "), "[", 2)
population$two <- lapply(strsplit(as.character(population$Population..2011.Census..12.....of.Population.of.India..13.), "\\â "), "[", 1)

#TOR - I tried going through the code but couldn't get it create the proper $one table, it just made a string of NA's, str_extract code beow to extract number should also work
# population$one <-  str_extract(population$Population..2011.Census..12.....of.Population.of.India..13., "(?<=\\d{19}...)[0-9,]*") %>% str_replace_all(",","") %>% as.numeric()

population$one = gsub("\\s*\\([^\\)]+\\)","", population$one) #cleaning string

population$one = population$one %>% str_replace_all(pattern = "," , replacement = "") #removing commas

population = select(population, State.or.union.territory, one) #select only desired data

setdiff(population$State.or.union.territory, GDPindia$State.UT) #find the states that are in one dataset but not the other

#count <- rbind(bribe_sta, data.frame(states = setdiff(population$State.or.union.territory, bribe_sta$states), amount = rep(0, 13))) original
count <- rbind(bribe_sta, data.frame(states = setdiff(population$State.or.union.territory, bribe_sta$states), amount = rep(0, 12))) #create a dataframe with the states that are in one dataset and missing in the other, assign value 0, then rbind with the bribe_sta data to get full state list. #TOR - changed 13 to 12, said state #s were different

GDPindia1 <- select(GDPindia1,State.UT,GDP)
#countGDPindia = rbind(GPDindia1, data.frame(states = setdiff(population$State.or.union.territory, GPDindia1$State.UT), amount = rep(0, 7)))
countGDPindia = rbind(GDPindia1, data.frame(states = setdiff(population$State.or.union.territory, GPDindia1$State.UT), GDP = rep(0, 3)))  #TOR - 3 columns in GDPindia1, 2 in the created state set, adding select() around gdpindia1, the created colum is labeled amount, GDPIndia1 "GDP", renaming keep geting errors names not found - this variable (countgdpindia is never used below :O )

count <- count[-c(25, 28, 31, 40), ] #remove rows 25, 28, 31, 40 <- TOR - changes what states they refer to when the dataset is cleaned initially, what are the states?

population = population[-c(37), ] #remove rows 37, India, from population

GPDindia1 = select(GPDindia1, State.UT, GDP) #narrow down India

GPDindia1[which(with(GPDindia1, State.UT == "Manipur")), c(1)] = "ManipurÎ²" # rename columns

GPDindia1[which(with(GPDindia1, State.UT == "Chattisgarh")), c(1)] = "Chhattisgarh" # rename columns

GPDindia1[which(with(GPDindia1, State.UT == "Jammu & Kashmir")), c(1)] = "Jammu and Kashmir" # rename columns

GPDindia1[which(with(GPDindia1, State.UT == "Andaman & Nicobar Islands")), c(1)] = "Andaman and Nicobar Islands" # rename columns

Comparison1 = left_join(population, GPDindia1, by = c("State.or.union.territory" = "State.UT")) #join the population and gdp tables together

Comparison1[is.na(Comparison1)] <- 0 #set NA values to 0 

Comparison1 = transform(Comparison1, one = as.numeric(one)) #force population data to value

Comparison2 = mutate(Comparison1, GDP_per_Capita = GDP/one) #create new colun with gdp per capita

count[which(with(count, states == "Orissa")), c(1)] = "Odisha" #rename columns

count[which(with(count, states == "Manipur")), c(1)] = "ManipurÎ²" #rename columns

Comparison = left_join(Comparison2, count, by = c("State.or.union.territory" = "states")) #join the GDP per capita column with the bribes per state

bribe_number = df %>% group_by(states) %>% count(states) #create column with number of bribes per state 

bribe_number = bribe_number[-c(1, 10), ] #remove rows 1 and 10, andhra pradesh and Haryana (TOR - eh?)

bribe_number[which(with(bribe_number, states == "Orissa")), c(1)] = "Odisha" #rename columns

bribe_number[which(with(bribe_number, states == "Manipur")), c(1)] = "ManipurÎ²" #rename columns


newrow1 = c("Himachal Pradesh", "hallo")  #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow1)

newrow2 = c("Meghalaya", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow2)

newrow3 = c("Nagaland", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow3)

newrow4 = c("Goa", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow4)

newrow5 = c("Sikkim", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow5)

newrow6 = c("Puducherry", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow6)

newrow7 = c("Andaman and Nicobar Islands", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow7)

newrow8 = c("Dadra and Nagar Haveli", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow8)

newrow9 = c("Daman and Diu", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow9)

newrow10 = c("Lakshadweep", "hallo") #add row for state with value "hallo"
bribe_number = rbind(bribe_number, newrow10)

bribe_number$n =  bribe_number$n %>% str_replace_all(pattern = "hallo" , replacement = "0") #replace hallo with 0

bribe_number = transform(bribe_number, n = as.numeric(n)) #force n to numeric to convert character 0's

Comparison3 = left_join(Comparison, bribe_number, by = c("State.or.union.territory" = "states")) #join the bribe number to the comparison dataset

Comparison4 = mutate(Comparison, money_per_bribe = amount/n()) #add column to comparison dataset with amount of bribe per report

names(Comparison4)[2] = "Population" #rename column 2 of comparison 4 to population

#Visualisation of GDP per capita and log(money per bribe), trying to see if there is a correlation between gdp per capita and the amount of money paid per bribe, e.g. do richer states have a higher bribe level than poorer states. 
p <- ggplot(Comparison4, aes(GDP_per_Capita, log(money_per_bribe)))
p + geom_point()
# 


## Timo

### Bribes per department

bribe_dep <- aggregate(amount ~ dep, df, sum)
bribe_dep$dep <- as.character(bribe_dep$dep)
bribe_dep[which(with(bribe_dep, dep == "Food, Civil Supplies and Consumer Affairs")), c(1)] <- "Food/Civil Supplies"

bribe_dep <- bribe_dep %>% filter(dep != "") %>% arrange(desc(amount))

bribe_dep$dep <- as.factor(bribe_dep$dep)

bribe_dep$dep = factor(bribe_dep$dep,levels(bribe_dep$dep)[c(8, 6, 11, 15, 2, 9, 16, 5, 3, 10, 14, 13, 4, 7, 17, 1, 12)])

p = ggplot(bribe_dep, aes(x = dep, y = amount, fill = dep))
p + geom_bar(stat="identity") + 
  theme_tufte() + 
  scale_y_continuous(labels=comma) +
  theme(axis.text.x = element_blank(),
        legend.position = "none") + 
  facet_wrap(~ dep, scales = "free_x") +
  scale_fill_viridis(discrete = TRUE)

## Visualize bribe/state

ind.df <- getData("GADM", country="IND", level=1)

count <- rbind(bribe_sta, data.frame(states = setdiff(ind.df$NAME_1, bribe_sta$states), amount = rep(0, 11)))

count <- count[-c(38),]
count <- count[-c(25),]

count[which(with(count, states == "Uttarakhand")), c(1)] <- "Uttaranchal"

count <- count[order(count$states, decreasing = FALSE),]

count$id <- c(1:36)

ind.df <- fortify(ind.df)

count$index <- as.numeric(tapply(ind.df$id, ind.df$id, length))
test <- data.frame(amount = count$amount, index = count$index)

test <- expandRows(test, "index")

ind.df$count <- test$amount

p2 <- ggplot() + 
  geom_polygon(data = ind.df, aes(x=long, y=lat, group=group, fill = count), colour = "black") +
  scale_fill_gradient("Bribes paid \nby state ", low="orange",high="red", breaks = c(0, 1e+06, 2e+06, 3e+06, 4e+06),
                      labels=c("0", "1M", "2M", "3M", "4M")) +
  labs(x="", y="", title="Total Amount of Bribes by State") + 
  theme(axis.ticks.y = element_blank(),axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),axis.text.x = element_blank(), 
        plot.title = element_text(lineheight=.8, face="bold", vjust=1))

```
